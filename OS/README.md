# 운영체제

* [프로세스와 스레드의 차이](#프로세스와-스레드의-차이)
* [Multiprocess 대신 Multithread를 사용하는 이유](#Multiprocess-대신-Multithread를-사용하는-이유)
* [Thread-safe](#Thread-safe)
* [동기화 객체의 종류](#동기화-객체의-종류)
* [뮤텍스와 세마포어의 차이](#뮤텍스와-세마포어의-차이)
---

### 프로세스와 스레드의 차이
* 프로세스(Process)란
    * 실행중인 프로그램
    * 디스크로부터 메모리에 적재되어 실행되고 있는 프로그램의 인스턴스
    * 운영체제로부터 "주소공간, 파일, 메모리" 등을 할당받는 작업의 단위
    * 특징
        * 프로세스는 각각 독립된 메모리 공간을 할당받는다.
            * Code : 함수, 제어문, 상수
            * Data : 전역변수
            * Heap : 프로세스 실행 중 동적으로 할당
            * Stack : 함수의 매개변수, 복귀 주소, 지역 변수
        * 프로세스 생성과 동시에 고유한 PCB를 생성한다.
        * 각 프로세스는 별도의 주소 공간에서 실행되며, 다른 프로세스의 자원에 접근 할 수 없다.
        * 다른 프로세스의 자원에 접근하려면 IPC를 사용해야 된다.

* 스레드(Thread)란
    * 한 프로세스 내에서 동작되는 여러 실행 흐름
    * 특징
        * 같은 프로세스에 속한 다른 스레드와 Code, Data, Heap 영역을 공유한다.
        * 스레드마다 Stack을 독립적으로 할당한다.
            * Stack에는 함수 호출 시 전달되는 인자, 되돌아가기 위한 주소값 등을 저장하기 위한 공간이기 때문이다. 이를 통해 독립적인 함수 호출이 가능하며 독립적인 실행 흐름을 추가하는 것이 가능하다.
        * 스레드마다 PC Register를 독립적으로 할당한다.
        * 한 스레드가 프로세스의 자원을 변경할 경우, 다른 스레드도 변경된 결과를 바로 확인할 수 있다.

### Multiprocess 대신 Multithread를 사용하는 이유
* 멀티프로세스(Multiprocess)란
    * 여러 개의 CPU를 사용해 여러 프로세스를 동시에 수행하는 것
* 멀티스레드(Multithread)란
    * 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것
* 멀티프로세스 대신 멀티 스레드를 사용하는 이유
    * 자원 사용 및 관리의 효율성
        * 프로세스를 생성해 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
        * 스레드는 프로세스 내의 메모리를 공유하므로 스레드간 데이터를 주고 받는 것이 간단해지고 자원 소모가 감소한다.
    * 처리 비용 감소 및 응답 시간 단축
        * 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적다.
        * 스레드 간의 context switch는 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.(Stack만 문맥전환하면 된다.)
* 멀티스레드의 문제점
    * 스레드간에 자원 공유가 이뤄지기 때문에 동기화 작업이 필요하다.
    * 동기화 작업으로 인해 병목 현상이 발생해 성능이 저하될 수도 있다.

### Thread-safe
* Thread-safe란
    * 멀티스레드 환경에서 여러 스레드가 동시에 하나의 공유 자원에 접근하더라도 프로그램의 실행에 문제가 없는 것
* Thread-safe를 지키기 위한 방법
    * Reentrant : 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장한다.
    * Thread-local storage : 공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소를 사용함으로써 동시 접근을 막는다.
    * Mutual exclusion : 공유 자원을 사용해야 되는 경우에는 해당 자원의 접근을 lock으로 통제한다.
    * Atomic operations : 공유 자원에 접근할 때 원자 연산을 이용한다.

### 동기화 객체의 종류
* 동기화 기법의 종류
    * 유저 모드 동기화
        * 커널 코드가 실행되지 않는 동기화 기법
        * 예) Critical Section, InterLock 함수
    * 커널 모드 동기화
        * 커널에서 제공하는 동기화 기능을 활용
        * 예) Mutex, Semaphore, Event

### 뮤텍스와 세마포어의 차이
* 뮤텍스(Mutex)란
    * 공유 자원에 **여러 스레드**가 접근하는 것을 막는 것
    * Mutual Exclusion을 의미, 임계 구역을 가진 스레드의 running time이 서로 겹치지 않도록 각각 단독으로 실행하게 하는 것.
    * 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다.
    * 자원을 lock & unlock 하는 코드
    ```
    acquire(){
        while(!available)
            ; /* busy wait */
        available=false;
    }

    release(){
        available = true;
    }

    do{
        acquire()
            
        critical section

        release()

        remainder section
    }while(true);
    ```
* 세마포어(Semaphore)란
    * 공유 자원에 **여러 프로세스**가 접근하는 것을 막는 것
    * 공유자원의 개수를 나타내는 변수
    * S 값이 0일 경우 사용 가능한 자원이 없는 것이므로 기다린다.
    * 일반적으로 긴 시간을 확보하는 자원에 대해 이용한다.
    * wait() & signal()
    ```
    wait(S){
        while(S<=0)
            ; /* busy wait */
        S--; /* 자원을 사용한다 */
    }

    signal(S){
        S++; /* 자원을 반환한다. */
    }

    do{
        wait(S);

        critical section

        signal(S);

        remainder section
    }while(true);
    ```
    * 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야한다.
* 뮤텍스 vs 세마포어
    * **동기화 대상의 개수**
        * 뮤텍스는 1개, 세마포어는 하나 이상
    * 뮤텍스는 뮤텍스를 소유하고 있는 스레드가 이 뮤텍스를 해제할 수 있다. 하지만 세마포어는 세마포어를 소유하지 않은 스레드가 세마포어를 해제할 수 있다.
    * 세마포어는 시스템 범위에 걸쳐있고, 파일 형태로 존재하는 반면 뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 초기화 된다.
    * 세마포어는 소유할 수 없지만, 뮤텍스는 소유가 가능하며 소유주가 책임을 진다.(뮤텍스는 상태가 2개인 lock이므로 lock을 가질 수 있다.)